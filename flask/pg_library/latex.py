#!/usr/bin/env python3

# Physics Derivation Graph
# Ben Payne, 2021
# https://creativecommons.org/licenses/by/4.0/
# Attribution 4.0 International (CC BY 4.0)

"""
The purpose of this file is 
"""

import random
import re
import os
import glob
import time

# move and copy files
import shutil
from subprocess import PIPE  # https://docs.python.org/3/library/subprocess.html
import subprocess  # https://stackoverflow.com/questions/39187886/what-is-the-difference-between-subprocess-popen-and-subprocess-run/39187984

import compute
import neo4j_query

proc_timeout = 30


def make_string_safe_for_latex(unsafe_str: str) -> str:
    """
    latex characters that require an escape for printing:
    # $ % & \ ^ _ { }
    TODO: I'm not escaping all of these

    Args:
        unsafe_str: strings that may cause Latex compilation to fail, e.g., "a_string" or "url#subsection"
    Returns:
        safe_str: a string that latex should be able to print, e.g., "a\_string" or "url\#subsection"
    """
    # some derivation notes have valid underscores, like
    # \cite{yyyy_author}
    # while some underscores are invalid latex, like
    # https://en.wikipedia.org/wiki/Equations_of_motion
    # --> Remove citations
    # problem: using
    # re.sub(r'cite{.*}', '', some_text)
    # on the string
    # some_text = "an example cite{2222_asdf} and http://asdf_fagaaf and cite{9492_942} of http:/ss_asdf and more"
    # is greedy
    # to use a non-greedy search; https://stackoverflow.com/a/2503438/1164295
    # unsafe_str_without_citations = re.sub(r"cite{.*?}", "", unsafe_str)

    # replace the first _ that occurs within citation with another string
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str
    )
    # that approach breaks when cite has more than one underscore, for example
    # \cite{yyyy_author1_author2}
    unsafe_str_replaced_cite = re.sub(
        r"cite{(.*?)_(.*?)}", "cite{\\1NONSTANDARDUNDRSCR\\2}", unsafe_str_replaced_cite
    )

    safe_str = unsafe_str_replaced_cite.replace("_", "\_").replace("%", "\%")

    fixed_underscore_str = safe_str.replace("NONSTANDARDUNDRSCR", "_")

    no_hashtag_str = (
        fixed_underscore_str.replace("#", "\#").replace("$", "\$").replace("%", "\%")
    )

    return no_hashtag_str


def generate_tex_file_for_derivation(
    graphDB_Driver, query_time_dict: dict, derivation_id: str, path_to_tex_file: str
) -> str:
    """
    In v7 the PDG I started allowing inference rule names
    to have spaces. (In versions prior to 7 the inference rule names were
    camel case.) When I implemented this function in v7 I learned why the
    inference rule names had been camel case: Latex does not like
    newcommand names to have underscore in them; see https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
    Therefore, I remove all spaces from the inference rule name.

    Args:
        query_time_dict:
        derivation_id: numeric identifier of the derivation
    Returns:
        tex_filename: pass back filename without extension because bibtex cannot handle .tex
    Raises:

    >>> path_to_tex_file = "/home/appuser/app/static/"  # must end with /
    >>> generate_tex_for_derivation("000001")
    """

    trace_id = str(random.randint(1000000, 9999999))
    print("[TRACE] func: app/to_add_derivation start " + trace_id)

    tex_filename = derivation_id

    compute.remove_file_debris(
        [path_to_tex_file, "./"], [tex_filename], ["tex", "log", "pdf", "aux"]
    )

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        list_of_inference_rule_dicts = session.read_transaction(
            neo4j_query.get_list_node_dicts_of_type, "inference_rule"
        )

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        derivation_dict = session.read_transaction(
            neo4j_query.get_node_properties, "derivation", derivation_id
        )
    print("latex/generate_tex_file_for_derivation: derivation_dict=", derivation_dict)

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        list_of_step_dicts_in_this_derivation = session.read_transaction(
            neo4j_query.get_list_of_step_dicts_in_this_derivation, derivation_id
        )

    with graphDB_Driver.session() as session:
        query_start_time = time.time()
        list_of_sequence_values = session.read_transaction(
            neo4j_query.get_list_of_sequence_values_for_derivation_id, derivation_id
        )
    print(
        "latex/generate_tex_file_for_derivation: list_of_sequence_values=",
        list_of_sequence_values,
    )

    with open(tex_filename + ".tex", "w") as lat_file:
        lat_file.write(
            "% this tex file was generated by the Physics Derivation Graph \n"
        )
        lat_file.write("\\documentclass[12pt]{article}\n")  # article or report
        #        lat_file.write('\\thispagestyle{empty}\n')
        lat_file.write(
            "\\usepackage{amsmath,amssymb,amsfonts}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        lat_file.write(
            "\\usepackage[dvipdfmx,colorlinks=true,pdfkeywords={physics derivation graph}]{hyperref}\n"
        )
        lat_file.write("\\usepackage{graphicx} % for including PNG files\n")
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        # first, write the inference rules as newcommand at top of .tex file
        lat_file.write("% inference rules as newcommand for use in the body\n")
        for infrule_dict in list_of_inference_rule_dicts:
            number_of_args = (
                infrule_dict["number_of_feeds"]
                + infrule_dict["number_of_inputs"]
                + infrule_dict["number_of_outputs"]
            )
            # https://en.wikibooks.org/wiki/LaTeX/Macros#New_commands
            if number_of_args < 10:
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(
                        filter(str.isalpha, infrule_dict["name_latex"])
                    )  # digits cannot be used to name macros. FAULT EXPECTED: This filtering will create a collision if the only characters distinguishing infrules is a digit
                    + "["
                    + str(  # https://tex.stackexchange.com/questions/306110/new-command-with-an-underscore
                        number_of_args  # macros are limited to 9 inputs;
                    )
                    + "]{"
                    + infrule_dict["latex"]
                    + "}\n"
                )
            else:  # 10 or more args; see https://www.texfaq.org/FAQ-moren9
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "[9]{"
                    + "\\def\\ArgOne{{#1}}\n\\def\\ArgTwo{{#2}}\n\\def\\ArgThree{{#3}}\n\\def\\ArgFour{{#4}}\n\\def\\ArgFive{{#5}}\n"
                    + "\\def\\ArgSix{{#6}}\n\\def\\ArgSeven{{#7}}\n\\def\\ArgEight{{#8}}\n\\def\\ArgNine{{#9}}\n\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "Relay\n"
                    + "}\n"
                )
                lat_file.write(
                    "\\newcommand\\"
                    + "".join(filter(str.isalpha, infrule_dict["name_latex"]))
                    + "Relay["
                    + str(number_of_args - 9)
                    + "]{"
                    + infrule_dict["latex"]
                    .replace("#1", "ArgOne")
                    .replace("#2", "ArgTwo")
                    .replace("#3", "ArgThree")
                    .replace("#4", "ArgFour")
                    .replace("#5", "ArgFive")
                    .replace("#6", "ArgSix")
                    .replace("#7", "ArgSeven")
                    .replace("#8", "ArgEight")
                    .replace("#9", "ArgNine")
                    .replace("#10", "#1")
                    .replace("#11", "#2")
                    .replace("#12", "#3")
                    .replace("#13", "#4")
                    .replace("#14", "#5")
                    + "}\n"
                )

        lat_file.write("\\title{" + derivation_dict["name_latex"] + "}\n")
        lat_file.write("\\date{\\today}\n")
        lat_file.write("\\author{" + derivation_dict["author_name_latex"]) + "}\n"
        lat_file.write("\\setlength{\\topmargin}{-.5in}\n")
        lat_file.write("\\setlength{\\textheight}{9in}\n")
        lat_file.write("\\setlength{\\oddsidemargin}{0in}\n")
        lat_file.write("\\setlength{\\textwidth}{6.5in}\n")

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\maketitle\n")

        lat_file.write("\\begin{abstract}\n")
        lat_file.write(
            "Generated by the \\href{http://derivationmap.net/}{Physics Derivation Graph}.\n"
        )
        if len(derivation_dict["abstract_latex"]) > 0:
            # fixed bug https://github.com/allofphysicsgraph/proofofconcept/issues/249
            # safe_string = dat["derivations"][deriv_id]["notes"]
            #                lat_file.write(safe_string + "\n")
            lat_file.write(derivation_dict["abstract_latex"] + "\n")
        lat_file.write("\\end{abstract}\n")

        for linear_indx in list_of_sequence_values:
            for step_dict in list_of_step_dicts_in_this_derivation:
                if step_dict["linear index"] == linear_indx:
                    if "image" in step_dict.keys():
                        lat_file.write("\\begin{center}\n")
                        lat_file.write("\\begin{figure}\n")
                        #        shutil.copy(
                        #            "static/diagrams/" + step_dict["image"]["file name"],
                        #        step_dict["image"]["file name"],
                        # )
                        lat_file.write(
                            "\\includegraphics{"
                            + step_dict["image"]["file name"]
                            + "}\n"
                        )
                        lat_file.write(
                            "\\caption{" + step_dict["image"]["caption"] + "}\n"
                        )
                        lat_file.write(
                            "\\label{fig:" + step_dict["image"]["label"] + "}\n"
                        )
                        lat_file.write("\\end{figure}\n")
                        lat_file.write("\\end{center}\n")
                    # using the newcommand, populate the expression identifiers
                    lat_file.write("% step ID = " + step_dict["id"] + "\n")
                    lat_file.write(
                        # digits cannot be used to name macros
                        "\\"
                        + "".join(filter(str.isalpha, step_dict["inference_rule"]))
                    )
                    for expr_local_id in step_dict["feeds"]:
                        #                        lat_file.write("{" + expr_local_id + "}")
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write(
                            "{" + dat["expressions"][expr_global_id]["latex"] + "}"
                        )
                    for expr_local_id in step_dict["inputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    for expr_local_id in step_dict["outputs"]:
                        # expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("{" + expr_local_id + "}")
                    lat_file.write("\n")
                    if len(step_dict["notes"]) > 0:
                        lat_file.write(
                            step_dict["notes"] + "\n"
                        )  # TODO: if the note contains a $ or %, shenanigans arise
                    # write output expressions
                    for expr_local_id in step_dict["outputs"]:
                        expr_global_id = dat["expr local to global"][expr_local_id]
                        lat_file.write("\\begin{equation}\n")
                        lat_file.write(
                            dat["expressions"][expr_global_id]["latex"] + "\n"
                        )
                        lat_file.write("\\label{eq:" + expr_local_id + "}\n")
                        lat_file.write("\\end{equation}\n")

        lat_file.write("\\bibliographystyle{plain}\n")
        lat_file.write("\\bibliography{pdg.bib}\n")
        lat_file.write("\\end{document}\n")
        lat_file.write("% EOF\n")

    shutil.copy(tex_filename + ".tex", path_to_tex_file + tex_filename + ".tex")
    # logger.info("[trace end " + trace_id + "]")
    return tex_filename  # pass back filename without extension because bibtex cannot handle .tex


def FROMv7_NOT_YET_CONVERTED_generate_pdf_for_derivation(
    graphDB_Driver, query_time_dict: dict, derivation_id: str, path_to_pdf: str
) -> str:
    """

    Args:
        deriv_id: numeric identifier of the derivation
        path_to_pdf = "/home/appuser/app/static/"  # must end with /
    Returns:
        pdf_filename + ".pdf":
    Raises:

    >>> generate_pdf_for_derivation("000001", "myemail@address.com","pdg.db")
    """
    trace_id = str(random.randint(1000000, 9999999))
    # logger.info("[trace start " + trace_id + "]")
    # dat = clib.read_db(path_to_db)

    # to isolate the build process, create a temporary folder
    tmp_latex_folder = "tmp_latex_folder_" + str(random.randint(1000000, 9999999))
    tmp_latex_folder_full_path = os.getcwd() + "/" + tmp_latex_folder + "/"
    os.mkdir(tmp_latex_folder_full_path)

    # destination for the PDF once file is built

    pdf_filename = derivation_id

    # no longer necessary since the temporary build folder is empty
    # compute.remove_file_debris([path_to_pdf], [pdf_filename], ["log", "pdf"])

    tex_filename_without_extension = generate_tex_file_for_derivation(
        graphDB_Driver, query_time_dict, derivation_id, path_to_pdf
    )
    shutil.move(tex_filename_without_extension + ".tex", tmp_latex_folder_full_path)

    # copy the current pdg.bib from static to local for use with bibtex when compiling tex to PDF
    # https://docs.python.org/3/library/shutil.html
    shutil.copy("/home/appuser/app/static/pdg.bib", tmp_latex_folder_full_path)
    # shutil.copy("/home/appuser/app/static/pdg.bib", "/home/appuser/app/")

    # images need to be in the temporary folder to compile the .tex to PDF
    # https://docs.python.org/3/library/shutil.html#shutil.copytree
    # shutil.copytree(
    #        "/home/appuser/app/static/diagrams/", tmp_latex_folder_full_path
    # )
    for filename in glob.glob("/home/appuser/app/static/diagrams/*"):
        # logger.info("copied "+filename+" from "+filename+" to "+tmp_latex_folder_full_path)
        shutil.copy(filename, tmp_latex_folder_full_path)

    # TODO: it would be good to check whether \cite appears in the .tex content

    # first of the latex runs
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    latex_stdout = process.stdout.decode("utf-8")
    latex_stderr = process.stderr.decode("utf-8")

    # logger.debug("latex std out: %s", latex_stdout)
    # logger.debug("latex std err: %s", latex_stderr)

    if "Text line contains an invalid character" in latex_stdout:
        # logger.error("no PDF generated - tex contains invalid character")
        raise Exception("no PDF generated - tex contains invalid character")
    if "No pages of output." in latex_stdout:
        # logger.error("no PDF generated - reason unknown")
        raise Exception("no PDF generated - reason unknown")

    # first of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    # logger.debug("bibtex std out: %s", bibtex_stdout)
    # logger.debug("bibtex std err: %s", bibtex_stderr)

    # second of two bibtex runs
    process = subprocess.run(
        ["bibtex", tex_filename_without_extension],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )
    # https://stackoverflow.com/questions/41171791/how-to-suppress-or-capture-the-output-of-subprocess-run
    bibtex_stdout = process.stdout.decode("utf-8")
    bibtex_stderr = process.stderr.decode("utf-8")
    # logger.debug("bibtex std out: %s", bibtex_stdout)
    # logger.debug("bibtex std err: %s", bibtex_stderr)

    # run latex a second time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/204291/bibtex-latex-compiling
    # run latex a third time to enable references to work
    process = subprocess.run(
        ["latex", "-halt-on-error", tex_filename_without_extension + ".tex"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    # https://tex.stackexchange.com/questions/73783/dvipdfm-or-dvipdfmx-or-dvipdft
    # TODO: how does dvipdfmx know the name of the .tex input? In the process below only the output filename is specified (!)
    process = subprocess.run(
        ["dvipdfmx", pdf_filename + ".dvi"],
        cwd=tmp_latex_folder_full_path,
        stdout=PIPE,
        stderr=PIPE,
        timeout=proc_timeout,
    )

    dvipdf_stdout = process.stdout.decode("utf-8")
    dvipdf_stderr = process.stderr.decode("utf-8")

    # logger.debug("dvipdf std out: %s", dvipdf_stdout)
    # logger.debug("dvipdf std err: %s", dvipdf_stderr)

    shutil.move(
        tmp_latex_folder_full_path + pdf_filename + ".pdf",
        path_to_pdf + pdf_filename + ".pdf",
    )
    shutil.rmtree(tmp_latex_folder_full_path)
    # return True, pdf_filename + ".pdf"
    # logger.info("[trace end " + trace_id + "]")
    return pdf_filename + ".pdf"


def FROMv7_NOT_YET_CONVERTED_create_tex_file_for_expression(
    tmp_file: str, input_latex_str: str
) -> None:
    """

    Args:
        tmp_file:
        input_latex_str
    Returns:
        None

    Raises:

    >>> create_tex_file_for_expr('filename_without_extension', 'a \dot b \\nabla')
    """
    trace_id = str(random.randint(1000000, 9999999))
    # logger.info("[trace start " + trace_id + "]")

    compute.remove_file_debris(["./"], [tmp_file], ["tex"])

    with open(tmp_file + ".tex", "w") as lat_file:
        lat_file.write("\\documentclass[12pt]{article}\n")
        lat_file.write("\\thispagestyle{empty}\n")
        # https://tex.stackexchange.com/questions/73016/how-do-i-install-an-individual-package-on-a-linux-system
        # if "usepackage{braket}" is on and the package is not available, the process pauses while waiting for user input
        # the web interface is not aware of this pause, so the page hangs
        # lat_file.write("\\usepackage{braket}\n")
        lat_file.write(
            "\\usepackage{amsmath}\n"
        )  # https://tex.stackexchange.com/questions/32100/what-does-each-ams-package-do
        # lat_file.write("\\newcommand{\\when}[1]{{\\rm \\ when\\ }#1}\n")
        # lat_file.write("\\newcommand{\\bra}[1]{\\langle #1 |}\n")
        # lat_file.write("\\newcommand{\\ket}[1]{| #1\\rangle}\n")
        # lat_file.write("\\newcommand{\\op}[1]{\\hat{#1}}\n")
        # lat_file.write("\\newcommand{\\braket}[2]{\\langle #1 | #2 \\rangle}\n")
        # lat_file.write(
        #    "\\newcommand{\\rowCovariantColumnContravariant}[3]{#1_{#2}^{\\ \\ #3}} % left-bottom, right-upper\n"
        # )
        # lat_file.write(
        #    "\\newcommand{\\rowContravariantColumnCovariant}[3]{#1^{#2}_{\\ \\ #3}} % left-upper, right-bottom\n"
        # )

        lat_file.write("\\begin{document}\n")
        lat_file.write("\\huge{\n")
        lat_file.write("$" + input_latex_str + "$\n")
        lat_file.write("}\n")
        lat_file.write("\\end{document}\n")
    # logger.debug("wrote tex file")
    # logger.info("[trace end " + trace_id + "]")
    return
